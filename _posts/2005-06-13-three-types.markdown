---
layout: post
title: Three Types
date: '2005-06-13 23:31:57 -0700'
mt_id: 938
blog_id: 1
post_id: 938
basename: three-types
categories:
- programming
---
<br />In my life, I've met quite a few programmers, developers, and engineers. I've also read a lot of source code. In my experience, I've seen three types of programmers (or three styles of coding, if you prefer): neurotic, cavalier, and reasonable.<br /><br />The neurotic programmer seems to believe that anything could happen, that reality is a bewildering place. For some reason, he behaves as if computers aren't <a href="http://en.wikipedia.org/wiki/Deterministic_algorithm">deterministic</a>. He programs by the "what if": what if this suddenly worked differently, what if some hacker was able to override this somehow, what if everything failed. On the face of it, he might appear cautious to outsiders. His boss, who was probably never a developer, might encourage his attitude since "it's better to be safe than sorry." In the end, though, it's deuces wild and you had better encase everything in try-catches.<br /><br />The cavalier programmer doesn't really think about what might happen. He knows that computers are deterministic and predictable, but he arrives at that conclusion through trial and error. It's a pragmatic way of programming: write some code, compile, and see what comes out. If it doesn't work (or doesn't compile), then it's time to try a different route. And so on and so on. Generally, he only uses exception handling when he's seen an exception. While this way of programming generally works in the end, it's a very tentative kind of working and inevitably degrades into hackiness as new bugs crop up.<br /><br />The reasonable programmer knows that computers are predictable: garbage in, garbage out. He knows that they sometimes appear non-deterministic, but that that's just because his context doesn't yet include an understanding of what just happened. After a little research and pondering the situation, he can improve his understanding. He writes units of code, compiles, and then tests the code; not because he's unsure of himself or the nature of the programming environment, but because he doesn't want to get too far programming before he makes an error. He includes exception handling when it makes sense&#x2014;<em>i.e.</em>, when an exception is likely or important. There are still going to be bugs in the reasonable programmer's code, but they should be transitory since he's got a good handle on the program's operation.<br /><br />I've seen quite a few programmers fall into the neurotic category. I can understand why since computers are so complex and are often temporarily bewildering. Unfortunately, I've also met my share of cavalier programmers and I've read enough of other's experiences to know that it's regrettably prevalent. I believe that those programmers are probably in over their head, so to speak, and they've just given up on comprehending their world. While I can understand how they got to be what they are, I can't say that I'm terribly sympathetic because both types are pretty stagnant.<br /><br />Luckily, I've also met a lot of reasonable programmers (or read their source code). I'm pretty sure that most programmers would fall into that category, but there's also the possibility that any specific programmer may be an amalgam of the three. In that case, you might see flashes of one or the other at any given time.<br /><br />[NOTE: I debated about whether to write about these three styles as they evince themselves in code, but I decided ultimately that code doesn't write itself, code usually doesn't have one mind behind it, and the style of a piece of code is what it is because of the human mind that called it forth. Also, I'm not referring to anyone in particular&#x2014;they're composites of many programmers I've met.]<br /><br /><br />
